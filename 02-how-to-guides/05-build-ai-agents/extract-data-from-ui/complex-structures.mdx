---
title: Complex Structures
description: Extract nested and complex data using advanced Pydantic models
---

For sophisticated UIs, you'll need to extract complex, nested data structures. This guide shows advanced patterns using Pydantic models.

## Nested Data Models

Create models that reflect your UI's data hierarchy:

```python
from askui import ResponseSchemaBase
from typing import List, Optional, Dict
from datetime import datetime
from askui import Agent

agent = Agent()
agent.start()

class Address(ResponseSchemaBase):
    street: str
    city: str
    state: str
    zip_code: str

class ContactInfo(ResponseSchemaBase):
    email: str
    phone: Optional[str] = None
    address: Optional[Address] = None

class User(ResponseSchemaBase):
    id: int
    name: str
    role: str
    contact: ContactInfo
    permissions: List[str]
    metadata: Dict[str, str]

# Extract complex user data
user_data = agent.get(
    "Extract the complete user profile information",
    response_schema=User
)
```

## Form Data with Validation States

Extract form data along with validation information:

```python
class FieldValidation(ResponseSchemaBase):
    is_valid: bool
    error_message: Optional[str] = None

class FormField(ResponseSchemaBase):
    field_name: str
    field_type: str  # "text", "email", "select", etc.
    value: Optional[str] = None
    is_required: bool
    validation: FieldValidation

class Form(ResponseSchemaBase):
    form_name: str
    fields: List[FormField]
    can_submit: bool

# Extract entire form state
form_state = agent.get(
    "Extract the complete form including all fields and their validation states",
    response_schema=Form
)

# Check for errors
invalid_fields = [f for f in form_state.fields if not f.validation.is_valid]
if invalid_fields:
    for field in invalid_fields:
        print(f"{field.field_name}: {field.validation.error_message}")
```

## Multi-Step Wizard Data

For multi-step forms or wizards:

```python
class WizardStep(ResponseSchemaBase):
    step_number: int
    title: str
    is_completed: bool
    is_current: bool
    fields: List[FormField]

class WizardState(ResponseSchemaBase):
    total_steps: int
    current_step: int
    steps: List[WizardStep]
    can_proceed: bool
    can_go_back: bool

wizard = agent.get(
    "Extract the complete wizard state",
    response_schema=WizardState
)

# Navigate wizard
if wizard.can_proceed:
    agent.click("Next")
elif not wizard.steps[wizard.current_step - 1].is_completed:
    print("Current step has errors")
```

## Dynamic Schema Generation

Create schemas based on runtime information:

```python
from typing import Any

def create_dynamic_model(fields: List[str]):
    """Create a Pydantic model with dynamic fields"""
    class DynamicModel(ResponseSchemaBase):
        data: Dict[str, Any]
        
        class Config:
            extra = "allow"
    
    return DynamicModel

# First, discover what fields exist
available_fields = agent.get(
    "What data fields are shown in the details panel?",
    response_schema=List[str]
)

# Create and use dynamic model
DynamicModel = create_dynamic_model(available_fields)
extracted_data = agent.get(
    "Extract all data from the details panel",
    response_schema=DynamicModel
)
```

## Shopping Cart with Nested Items

Complex e-commerce data extraction:

```python
class ProductVariant(ResponseSchemaBase):
    size: Optional[str] = None
    color: Optional[str] = None
    material: Optional[str] = None

class CartItem(ResponseSchemaBase):
    product_id: str
    product_name: str
    variant: ProductVariant
    quantity: int
    unit_price: float
    subtotal: float
    discounts: List[str] = []

class ShippingOption(ResponseSchemaBase):
    method: str
    price: float
    estimated_days: int
    is_selected: bool

class Cart(ResponseSchemaBase):
    items: List[CartItem]
    subtotal: float
    tax: float
    shipping: ShippingOption
    total: float
    promo_codes: List[str] = []

# Extract complete cart
cart_data = agent.get(
    "Extract the complete shopping cart information",
    response_schema=Cart
)

# Validate cart calculations
calculated_subtotal = sum(item.subtotal for item in cart_data.items)
assert abs(calculated_subtotal - cart_data.subtotal) < 0.01
```

## Project Management Dashboard

Extract complex project data:

```python
class TaskAssignee(ResponseSchemaBase):
    name: str
    avatar_url: str
    email: str

class Task(ResponseSchemaBase):
    id: str
    title: str
    status: str
    priority: str
    assignees: List[TaskAssignee]
    due_date: Optional[str] = None
    tags: List[str]
    completion_percentage: int

class ProjectPhase(ResponseSchemaBase):
    name: str
    status: str
    tasks: List[Task]
    start_date: str
    end_date: str

class Project(ResponseSchemaBase):
    name: str
    description: str
    phases: List[ProjectPhase]
    team_members: List[TaskAssignee]
    overall_progress: int

# Extract project dashboard
project = agent.get(
    "Extract the complete project dashboard data",
    response_schema=Project
)

# Analyze project status
overdue_tasks = []
for phase in project.phases:
    for task in phase.tasks:
        if task.due_date and task.status != "completed":
            # Check if overdue (implement date comparison)
            overdue_tasks.append(task)
```

## Recursive Comment Threads

For nested discussions or comments:

```python
class CommentAuthor(ResponseSchemaBase):
    name: str
    avatar: str
    role: Optional[str] = None

class Comment(ResponseSchemaBase):
    id: str
    author: CommentAuthor
    content: str
    timestamp: str
    likes: int
    replies: List['Comment'] = []  # Recursive reference

class Discussion(ResponseSchemaBase):
    title: str
    original_post: Comment
    total_replies: int

# Extract discussion thread
discussion = agent.get(
    "Extract the complete discussion thread",
    response_schema=Discussion
)

# Count all comments recursively
def count_comments(comment: Comment) -> int:
    return 1 + sum(count_comments(reply) for reply in comment.replies)

total_comments = count_comments(discussion.original_post)
```

## Best Practices for Complex Extraction

1. **Start Simple, Then Expand**: Build your model incrementally
   ```python
   # Start with basic model
   class BasicProduct(ResponseSchemaBase):
       name: str
       price: float
   
   # Test basic extraction first
   basic = agent.get("Extract product", response_schema=BasicProduct)
   
   # Then expand to complex model
   class DetailedProduct(ResponseSchemaBase):
       name: str
       price: float
       variants: List[ProductVariant]
       reviews: List[Review]
       # ... more fields
   ```

2. **Use Field Validators**: Add validation to your models
   ```python
   from pydantic import validator
   
   class ValidatedData(ResponseSchemaBase):
       email: str
       age: int
       
       @validator('email')
       def email_must_be_valid(cls, v):
           if '@' not in v:
               raise ValueError('Invalid email')
           return v
       
       @validator('age')
       def age_must_be_positive(cls, v):
           if v < 0:
               raise ValueError('Age must be positive')
           return v
   ```

3. **Handle Partial Data**: Use Optional fields for data that might not exist
   ```python
   class RobustModel(ResponseSchemaBase):
       # Required fields
       id: str
       name: str
       
       # Optional fields with defaults
       description: Optional[str] = None
       tags: List[str] = []
       metadata: Dict[str, Any] = {}
   ```

## Debugging Complex Extractions

When working with complex structures:

```python
# 1. Extract raw data first
raw_data = agent.get(
    "Extract all visible data as key-value pairs",
    response_schema=Dict[str, Any]
)
print("Raw data:", raw_data)

# 2. Test with simpler schema
class SimpleVersion(ResponseSchemaBase):
    basic_field: str

simple = agent.get("Extract basic info", response_schema=SimpleVersion)

# 3. Gradually add complexity
class ComplexVersion(ResponseSchemaBase):
    basic_field: str
    nested_data: Dict[str, Any]
    # Add more fields incrementally
```